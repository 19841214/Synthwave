<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON SHORTCUT RUNNER: ULTIMATE</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Audiowide&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #050010;
    font-family: 'Press Start 2P', cursive;
    color: white;
    user-select: none;
  }

  /* --- CRT è¢å¹•ç‰¹æ•ˆå±¤ (CSS Overlay) --- */
  #crt-overlay {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 100;
    background: 
      /* æƒæç·š */
      linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
      /* é›œè¨Šç´‹ç† (æ¨¡æ“¬) */
      linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
    background-size: 100% 2px, 3px 100%;
    box-shadow: inset 0 0 100px rgba(0,0,0,0.9); /* é‚Šè§’æš—è§’ */
  }

  /* è¢å¹•å¾®å¾®é–ƒçˆå‹•ç•« */
  @keyframes flicker {
    0% { opacity: 0.97; }
    5% { opacity: 0.95; }
    10% { opacity: 0.9; }
    15% { opacity: 0.95; }
    100% { opacity: 0.97; }
  }
  #game-container {
    animation: flicker 0.15s infinite;
  }

  /* UI ä»‹é¢ */
  #ui-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    pointer-events: none;
    z-index: 50;
    text-shadow: 2px 2px 0px #000, 0 0 10px rgba(255, 0, 255, 0.8);
  }

  .hud-top {
    display: flex;
    justify-content: space-between;
    font-size: 1.2rem;
    color: #0ff;
  }

  .hud-bottom {
    text-align: center;
    font-family: 'Audiowide', cursive; /* æ›´æœ‰ç§‘æŠ€æ„Ÿçš„å­—é«” */
    color: #888;
    font-size: 0.8rem;
    letter-spacing: 2px;
  }

  /* ä¸­å¤®é–‹å§‹ç•«é¢ */
  #start-screen {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 60;
  }

  h1 {
    font-family: 'Audiowide', cursive;
    font-size: 4rem;
    margin: 0;
    background: linear-gradient(to bottom, #0ff, #f0f);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 20px #f0f);
    letter-spacing: 5px;
  }

  .blink-text {
    margin-top: 30px;
    font-size: 1.2rem;
    color: #ff0;
    animation: blink 1s steps(2, start) infinite;
  }

  @keyframes blink {
    to { visibility: hidden; }
  }

  /* ç­”å°æ™‚çš„é£„å­—ç‰¹æ•ˆ */
  .floating-text {
    position: absolute;
    color: #fff;
    font-weight: bold;
    pointer-events: none;
    animation: floatUp 1s forwards;
    text-shadow: 0 0 5px #fff;
  }

  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
  }

  /* Chromebook éµç›¤æç¤ºåœ– */
  .kb-hint {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #0ff;
    padding: 10px;
    border-radius: 5px;
    display: inline-block;
    margin-top: 10px;
    color: #0ff;
    font-size: 0.7rem;
  }
</style>
</head>
<body>

<div id="crt-overlay"></div>

<div id="ui-layer">
  <div class="hud-top">
    <div id="score-display">SCORE: 000000</div>
    <div id="combo-display">COMBO: 0</div>
    <div id="level-display">LEVEL 1</div>
  </div>
  <div class="hud-bottom">
    SYSTEM: CHROME_OS // KEYBOARD_INTERCEPT: ACTIVE
  </div>
</div>

<div id="start-screen">
  <h1>NEON<br>RUNNER</h1>
  <div class="kb-hint">HACK THE SYSTEM WITH SHORTCUTS</div>
  <div class="blink-text">PRESS [ENTER] TO START</div>
</div>

<div id="game-container">
  <canvas id="canvas"></canvas>
</div>

<script>
// ä½¿ç”¨ IIFE (ç«‹å³åŸ·è¡Œå‡½å¼) è§£æ±ºå…¨åŸŸè®Šæ•¸é‡è¤‡å®£å‘Šå•é¡Œ
(function() {

/**
 * ğŸµ Audio System (Web Audio API)
 * ç”Ÿæˆ 8-bit é¢¨æ ¼éŸ³æ•ˆï¼Œç„¡éœ€å¤–éƒ¨æª”æ¡ˆ
 */
const AudioSys = {
  ctx: null,
  init: function() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AudioContext();
  },
  playTone: function(freq, type, duration, vol=0.1) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  },
  playHit: function() { // ç­”å°é›·å°„è²
    this.playTone(800, 'sawtooth', 0.1, 0.1);
    setTimeout(() => this.playTone(1200, 'square', 0.1, 0.05), 50);
  },
  playError: function() { // ç­”éŒ¯ä½é »è²
    this.playTone(150, 'sawtooth', 0.2, 0.2);
  },
  playExplode: function() { // çˆ†ç‚¸å™ªéŸ³
    // ç°¡å–®æ¨¡æ“¬å™ªéŸ³
    if (!this.ctx) return;
    const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 sec
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    noise.connect(gain);
    gain.connect(this.ctx.destination);
    noise.start();
  },
  playLevelUp: function() {
    this.playTone(440, 'square', 0.1);
    setTimeout(() => this.playTone(554, 'square', 0.1), 100);
    setTimeout(() => this.playTone(659, 'square', 0.1), 200);
    setTimeout(() => this.playTone(880, 'square', 0.4), 300);
  }
};

/**
 * ğŸ® Game Data & Logic
 */
const LEVELS = [
  { 
    name: "SURVIVOR", color: "#00ffff", speed: 200, // åŸºç¤æ–‡æ›¸
    pool: [
      { label: "è¤‡è£½", hint: "Ctrl+C", code: { ctrl: true, key: 'c' } },
      { label: "è²¼ä¸Š", hint: "Ctrl+V", code: { ctrl: true, key: 'v' } },
      { label: "å‰ªä¸‹", hint: "Ctrl+X", code: { ctrl: true, key: 'x' } },
      { label: "å…¨é¸", hint: "Ctrl+A", code: { ctrl: true, key: 'a' } },
      { label: "å¾©åŸ", hint: "Ctrl+Z", code: { ctrl: true, key: 'z' } },
      { label: "æœå°‹", hint: "Ctrl+F", code: { ctrl: true, key: 'f' } },
      { label: "å­˜æª”", hint: "Ctrl+S", code: { ctrl: true, key: 's' } }
    ]
  },
  { 
    name: "EDITOR", color: "#ff00ff", speed: 250, // ç€è¦½å™¨æ“ä½œ
    pool: [
      { label: "ç²—é«”", hint: "Ctrl+B", code: { ctrl: true, key: 'b' } },
      { label: "æ–œé«”", hint: "Ctrl+I", code: { ctrl: true, key: 'i' } },
      { label: "åº•ç·š", hint: "Ctrl+U", code: { ctrl: true, key: 'u' } },
      { label: "æ›¸ç±¤", hint: "Ctrl+D", code: { ctrl: true, key: 'd' } },
      { label: "æ­·å²", hint: "Ctrl+H", code: { ctrl: true, key: 'h' } },
      { label: "ä¸‹è¼‰", hint: "Ctrl+J", code: { ctrl: true, key: 'j' } }
    ]
  },
  { 
    name: "HACKER", color: "#ffff00", speed: 320, // ç³»çµ±æ“ä½œ
    pool: [
      { label: "é å·¦", hint: "Alt+[", code: { alt: true, key: '[' } },
      { label: "é å³", hint: "Alt+]", code: { alt: true, key: ']' } },
      { label: "å¤§å¯«", hint: "Alt+ğŸ”", code: { alt: true, meta: true } },
      { label: "åˆªé™¤", hint: "Alt+Back", code: { alt: true, key: 'Backspace' } }
    ]
  }
];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let state = {
  screen: 'START', // START, PLAY, GAMEOVER
  score: 0,
  combo: 0,
  levelIdx: 0,
  shake: 0, // è¢å¹•éœ‡å‹•å€¼
  lastTime: 0
};

let entities = {
  enemies: [],
  particles: []
};

// å°ºå¯¸è™•ç†
let W, H, CX, CY;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  CX = W / 2;
  CY = H / 2;
}
window.addEventListener('resize', resize);
resize();

// --- Classes ---

class Enemy {
  constructor(data) {
    this.data = data;
    this.x = (Math.random() - 0.5) * W * 0.8; // éš¨æ©Ÿæ°´å¹³ä½ç½®
    this.y = H * 0.5; // åœ°å¹³ç·šé«˜åº¦
    this.z = 2000; // æ·±åº¦
    this.maxZ = 2000;
  }

  update(dt, speed) {
    this.z -= speed * dt;
    return this.z < 10; // æ’åˆ°ç©å®¶
  }

  draw(ctx) {
    const scale = 300 / (this.z + 10);
    const screenX = CX + this.x * scale;
    const screenY = H * 0.55 + 100 * scale; // ç•¥ä½æ–¼åœ°å¹³ç·š
    
    // æ ¹æ“šè·é›¢æ”¹è®Šé€æ˜åº¦
    const alpha = Math.min(1, (this.maxZ - this.z) / 500);
    
    // éœ“è™¹ç™¼å…‰
    ctx.shadowBlur = 15;
    ctx.shadowColor = LEVELS[state.levelIdx].color;
    ctx.fillStyle = "#fff";
    
    // ç¹ªè£½ä»»å‹™æ–‡å­— (ä¸­æ–‡)
    ctx.font = `${30 * scale}px 'Press Start 2P'`;
    ctx.textAlign = "center";
    ctx.fillText(this.data.label, screenX, screenY);
    
    // ç¹ªè£½æŒ‰éµæç¤º (è‹±æ–‡)
    ctx.shadowBlur = 0; // æç¤ºå­—ä¸ç™¼å…‰ä»¥ä¿æŒæ¸…æ™°
    ctx.fillStyle = LEVELS[state.levelIdx].color;
    ctx.font = `${14 * scale}px monospace`;
    ctx.fillText(this.data.hint, screenX, screenY + 40 * scale);
  }
}

class Particle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 5 + 2;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.life = 1.0;
    this.decay = Math.random() * 0.03 + 0.02;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.2; // é‡åŠ›
    this.life -= this.decay;
  }
  draw(ctx) {
    ctx.globalAlpha = Math.max(0, this.life);
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, 4, 4);
    ctx.globalAlpha = 1.0;
  }
}

// --- Game Functions ---

function spawnEnemy() {
  const pool = LEVELS[state.levelIdx].pool;
  const data = pool[Math.floor(Math.random() * pool.length)];
  entities.enemies.push(new Enemy(data));
}

function triggerShake(amount) {
  state.shake = amount;
}

function createExplosion(x, y, color) {
  for(let i=0; i<15; i++) {
    entities.particles.push(new Particle(x, y, color));
  }
}

function updateHUD() {
  document.getElementById('score-display').innerText = `SCORE: ${state.score.toString().padStart(6, '0')}`;
  document.getElementById('combo-display').innerText = `COMBO: ${state.combo}`;
  const lvlEl = document.getElementById('level-display');
  lvlEl.innerText = LEVELS[state.levelIdx].name;
  lvlEl.style.color = LEVELS[state.levelIdx].color;
}

function startGame() {
  if(!AudioSys.ctx) AudioSys.init();
  AudioSys.ctx.resume();
  
  state.screen = 'PLAY';
  state.score = 0;
  state.combo = 0;
  state.levelIdx = 0;
  entities.enemies = [];
  entities.particles = [];
  
  document.getElementById('start-screen').style.display = 'none';
  updateHUD();
  AudioSys.playLevelUp();
}

function gameOver() {
  state.screen = 'GAMEOVER';
  AudioSys.playError();
  document.getElementById('start-screen').style.display = 'block';
  document.querySelector('#start-screen h1').innerHTML = "GAME<br>OVER";
  document.querySelector('#start-screen .blink-text').innerText = "PRESS [ENTER] TO RESTART";
  document.querySelector('.kb-hint').innerText = `FINAL SCORE: ${state.score}`;
}

// --- Main Loop ---

let spawnTimer = 0;

function loop(timestamp) {
  const dt = (timestamp - state.lastTime) / 1000;
  state.lastTime = timestamp;

  // 1. æ¸…é™¤èˆ‡éœ‡å‹•è™•ç†
  ctx.fillStyle = "#050010";
  ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  if (state.shake > 0) {
    const dx = (Math.random() - 0.5) * state.shake;
    const dy = (Math.random() - 0.5) * state.shake;
    ctx.translate(dx, dy);
    state.shake *= 0.9; // éœ‡å‹•è¡°æ¸›
    if(state.shake < 0.5) state.shake = 0;
  }

  // 2. ç•«èƒŒæ™¯ (Synthwave Sun & Grid)
  drawBackground(timestamp);

  // 3. éŠæˆ²é‚è¼¯
  if (state.screen === 'PLAY') {
    // ç”Ÿæˆæ•µäºº
    spawnTimer += dt;
    const spawnRate = 2.0 - (state.levelIdx * 0.5); // è¶Šé›£ç”Ÿæˆè¶Šå¿«
    if (spawnTimer > spawnRate) {
      spawnEnemy();
      spawnTimer = 0;
    }

    // æ›´æ–°æ•µäºº
    entities.enemies.forEach((e, i) => {
      const hit = e.update(dt, LEVELS[state.levelIdx].speed);
      e.draw(ctx);
      if (hit) {
        triggerShake(20);
        AudioSys.playExplode();
        gameOver();
      }
    });
    // ç§»é™¤éé æˆ–å·²æ‰“æ‰çš„æ•µäºº
    entities.enemies = entities.enemies.filter(e => e.z > 0 && e.active !== false);

    // å‡ç´šé‚è¼¯
    if (state.score > 1500 && state.levelIdx === 0) { state.levelIdx = 1; AudioSys.playLevelUp(); triggerShake(10); }
    if (state.score > 3500 && state.levelIdx === 1) { state.levelIdx = 2; AudioSys.playLevelUp(); triggerShake(10); }
    
    updateHUD();
  }

  // 4. ç²’å­ç³»çµ± (ä»»ä½•ç‹€æ…‹éƒ½ç•«)
  entities.particles.forEach(p => {
    p.update();
    p.draw(ctx);
  });
  entities.particles = entities.particles.filter(p => p.life > 0);

  ctx.restore();
  requestAnimationFrame(loop);
}

function drawBackground(time) {
  const horizonY = H * 0.55;
  
  // ç•«å¤ªé™½
  const sunY = horizonY - 50;
  const sunGrad = ctx.createLinearGradient(CX, sunY - 150, CX, sunY + 150);
  sunGrad.addColorStop(0, "#ffdd00");
  sunGrad.addColorStop(1, "#ff00aa");
  
  ctx.save();
  ctx.fillStyle = sunGrad;
  ctx.shadowBlur = 50;
  ctx.shadowColor = "#ff00aa";
  ctx.beginPath();
  ctx.arc(CX, sunY, 120, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // å¤ªé™½åˆ‡å‰²ç·š (Retro Blinds)
  ctx.fillStyle = "#050010";
  for(let i=0; i<8; i++) {
    let y = sunY + 20 + i * 15;
    let h = 2 + i * 1.5;
    ctx.fillRect(CX - 130, y, 260, h);
  }

  // ç•«ç¶²æ ¼ (Grid)
  ctx.save();
  ctx.strokeStyle = "#ff00aa";
  ctx.lineWidth = 2;
  ctx.shadowBlur = 10;
  ctx.shadowColor = "#ff00aa";
  
  // ç¸±å‘ç·š (é€è¦–)
  ctx.beginPath();
  for (let i = -20; i <= 20; i++) {
    let x1 = CX + i * 40; // é è™•
    let x2 = CX + i * 800; // è¿‘è™•
    ctx.moveTo(x1, horizonY);
    ctx.lineTo(x2, H);
  }
  ctx.stroke();

  // æ©«å‘ç·š (ç§»å‹•å‹•ç•«)
  const speed = 150; // Grid moving speed
  const offset = (time / 1000 * speed) % 100;
  ctx.beginPath();
  for (let i = 0; i < 15; i++) {
    // æŒ‡æ•¸åˆ†ä½ˆè®“æ©«ç·šè¿‘å¤§é å°
    let z = i * 80 + offset;
    let y = horizonY + (z * z) / 2000; 
    if (y < H) {
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
    }
  }
  ctx.stroke();
  
  // åœ°å¹³ç·šç™¼å…‰æ¢
  ctx.shadowBlur = 30;
  ctx.shadowColor = "#fff";
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  ctx.lineTo(W, horizonY);
  ctx.stroke();
  
  ctx.restore();
}

/**
 * âŒ¨ï¸ Input Handling
 */
document.addEventListener('keydown', (e) => {
  // 1. æ””æˆªåŠŸèƒ½éµ
  if (e.ctrlKey || e.altKey || e.metaKey) {
    e.preventDefault();
  }

  // 2. é–‹å§‹éŠæˆ²
  if ((state.screen === 'START' || state.screen === 'GAMEOVER') && e.key === 'Enter') {
    startGame();
    return;
  }

  if (state.screen !== 'PLAY') return;

  // 3. æª¢æŸ¥ç­”æ¡ˆ
  // æ‰¾æœ€è¿‘çš„æ•µäºº
  let targetIdx = -1;
  let minZ = Infinity;
  entities.enemies.forEach((en, idx) => {
    if (en.z < minZ) { minZ = en.z; targetIdx = idx; }
  });

  if (targetIdx !== -1) {
    const enemy = entities.enemies[targetIdx];
    const code = enemy.data.code;

    // æ¯”å°é‚è¼¯
    const matchCtrl = !!code.ctrl === e.ctrlKey;
    const matchAlt = !!code.alt === e.altKey;
    const matchMeta = !!code.meta === e.metaKey;
    
    let matchKey = false;
    // è™•ç†ç‰¹æ®Šéµ
    if (code.key) {
      if (code.key.length === 1) {
        matchKey = e.key.toLowerCase() === code.key.toLowerCase();
      } else {
        // ç‰¹æ®Šéµå¦‚ Backspace
        matchKey = e.key === code.key;
      }
    } else {
      matchKey = true; // åªæœ‰åŠŸèƒ½éµçµ„åˆ
    }

    if (matchCtrl && matchAlt && matchMeta && matchKey) {
      // HIT!
      state.score += 100 + (state.combo * 10);
      state.combo++;
      triggerShake(5);
      AudioSys.playHit();
      AudioSys.playExplode(); // è¼•å¾®çˆ†ç‚¸è²
      
      // è¨ˆç®—çˆ†ç‚¸ä½ç½®
      const scale = 300 / (enemy.z + 10);
      const sx = CX + enemy.x * scale;
      const sy = H * 0.55 + 100 * scale;
      createExplosion(sx, sy, LEVELS[state.levelIdx].color);
      
      // é£„å­—
      const floatText = document.createElement('div');
      floatText.className = 'floating-text';
      floatText.style.left = sx + 'px';
      floatText.style.top = sy + 'px';
      floatText.innerText = "+100";
      document.body.appendChild(floatText);
      setTimeout(() => floatText.remove(), 1000);

      enemy.active = false; // æ¨™è¨˜ç§»é™¤
    } else {
      // MISS (optional: reset combo)
      // state.combo = 0;
    }
  }
});

// Start loop
requestAnimationFrame(loop);

})(); // IIFE çµæŸ
</script>
</body>
</html>